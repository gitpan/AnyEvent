NAME
    AnyEvent - provide framework for multiple event loops

    Event, Coro, Glib, Tk - various supported event loops

SYNOPSIS
       use AnyEvent;

       my $w = AnyEvent->io (fh => ..., poll => "[rw]+", cb => sub {
          my ($poll_got) = @_;
          ...
       });

    * only one io watcher per $fh and $poll type is allowed (i.e. on a
    socket you can have one r + one w or one rw watcher, not any more
    (limitation by Tk).

    * the $poll_got passed to the handler needs to be checked by looking for
    single characters (e.g. with a regex), as it can contain more event
    types than were requested (e.g. a 'w' watcher might generate 'rw'
    events, limitation by Glib).

    * AnyEvent will keep filehandles alive, so as long as the watcher
    exists, the filehandle exists.

       my $w = AnyEvent->timer (after => $seconds, cb => sub {
          ...
       });

    * io and time watchers get canceled whenever $w is destroyed, so keep a
    copy

    * timers can only be used once and must be recreated for repeated
    operation (limitation by Glib and Tk).

       my $w = AnyEvent->condvar; # kind of main loop replacement
       $w->wait; # enters main loop till $condvar gets ->broadcast
       $w->broadcast; # wake up current and all future wait's

    * condvars are used to give blocking behaviour when neccessary. Create a
    condvar for any "request" or "event" your module might create,
    "->broadcast" it when the event happens and provide a function that
    calls "->wait" for it. See the examples below.

DESCRIPTION
    AnyEvent provides an identical interface to multiple event loops. This
    allows module authors to utilizy an event loop without forcing module
    users to use the same event loop (as only a single event loop can
    coexist peacefully at any one time).

    The interface itself is vaguely similar but not identical to the Event
    module.

    On the first call of any method, the module tries to detect the
    currently loaded event loop by probing wether any of the following
    modules is loaded: Coro::Event, Event, Glib, Tk. The first one found is
    used. If none is found, the module tries to load these modules in the
    order given. The first one that could be successfully loaded will be
    used. If still none could be found, it will issue an error.

ENVIRONMENT VARIABLES
    The following environment variables are used by this module:

    "PERL_ANYEVENT_VERBOSE" when set to 2 or higher, reports which event
    model gets used.

EXAMPLE
    The following program uses an io watcher to read data from stdin, a
    timer to display a message once per second, and a condvar to exit the
    program when the user enters quit:

       use AnyEvent;

       my $cv = AnyEvent->condvar;

       my $io_watcher = AnyEvent->io (fh => \*STDIN, poll => 'r', cb => sub {
          warn "io event <$_[0]>\n";   # will always output <r>
          chomp (my $input = <STDIN>); # read a line
          warn "read: $input\n";       # output what has been read
          $cv->broadcast if $input =~ /^q/i; # quit program if /^q/i
       });

       my $time_watcher; # can only be used once

       sub new_timer {
          $timer = AnyEvent->timer (after => 1, cb => sub {
             warn "timeout\n"; # print 'timeout' about every second
             &new_timer; # and restart the time
          });
       }

       new_timer; # create first timer

       $cv->wait; # wait until user enters /^q/i

REAL-WORLD EXAMPLE
    Consider the Net::FCP module. It features (among others) the following
    API calls, which are to freenet what HTTP GET requests are to http:

       my $data = $fcp->client_get ($url); # blocks

       my $transaction = $fcp->txn_client_get ($url); # does not block
       $transaction->cb ( sub { ... } ); # set optional result callback
       my $data = $transaction->result; # possibly blocks

    The "client_get" method works like "LWP::Simple::get": it requests the
    given URL and waits till the data has arrived. It is defined to be:

       sub client_get { $_[0]->txn_client_get ($_[1])->result }

    And in fact is automatically generated. This is the blocking API of
    Net::FCP, and it works as simple as in any other, similar, module.

    More complicated is "txn_client_get": It only creates a transaction
    (completion, result, ...) object and initiates the transaction.

       my $txn = bless { }, Net::FCP::Txn::;

    It also creates a condition variable that is used to signal the
    completion of the request:

       $txn->{finished} = AnyAvent->condvar;

    It then creates a socket in non-blocking mode.

       socket $txn->{fh}, ...;
       fcntl $txn->{fh}, F_SETFL, O_NONBLOCK;
       connect $txn->{fh}, ...
          and !$!{EWOULDBLOCK}
          and !$!{EINPROGRESS}
          and Carp::croak "unable to connect: $!\n";

    Then it creates a write-watcher which gets called whenever an error
    occurs or the connection succeeds:

       $txn->{w} = AnyEvent->io (fh => $txn->{fh}, poll => 'w', cb => sub { $txn->fh_ready_w });

    And returns this transaction object. The "fh_ready_w" callback gets
    called as soon as the event loop detects that the socket is ready for
    writing.

    The "fh_ready_w" method makes the socket blocking again, writes the
    request data and replaces the watcher by a read watcher (waiting for
    reply data). The actual code is more complicated, but that doesn't
    matter for this example:

       fcntl $txn->{fh}, F_SETFL, 0;
       syswrite $txn->{fh}, $txn->{request}
          or die "connection or write error";
       $txn->{w} = AnyEvent->io (fh => $txn->{fh}, poll => 'r', cb => sub { $txn->fh_ready_r });

    Again, "fh_ready_r" waits till all data has arrived, and then stores the
    result and signals any possible waiters that the request ahs finished:

       sysread $txn->{fh}, $txn->{buf}, length $txn->{$buf};

       if (end-of-file or data complete) {
         $txn->{result} = $txn->{buf};
         $txn->{finished}->broadcast;
         $txb->{cb}->($txn) of $txn->{cb}; # also call callback
       }

    The "result" method, finally, just waits for the finished signal (if the
    request was already finished, it doesn't wait, of course, and returns
    the data:

       $txn->{finished}->wait;
       return $txn->{result};

    The actual code goes further and collects all errors ("die"s,
    exceptions) that occured during request processing. The "result" method
    detects wether an exception as thrown (it is stored inside the $txn
    object) and just throws the exception, which means connection errors and
    other problems get reported tot he code that tries to use the result,
    not in a random callback.

    All of this enables the following usage styles:

    1. Blocking:

       my $data = $fcp->client_get ($url);

    2. Blocking, but parallelizing:

       my @datas = map $_->result,
                      map $fcp->txn_client_get ($_),
                         @urls;

    Both blocking examples work without the module user having to know
    anything about events.

    3a. Event-based in a main program, using any support Event module:

       use Event;

       $fcp->txn_client_get ($url)->cb (sub {
          my $txn = shift;
          my $data = $txn->result;
          ...
       });

       Event::loop;

    3b. The module user could use AnyEvent, too:

       use AnyEvent;

       my $quit = AnyEvent->condvar;

       $fcp->txn_client_get ($url)->cb (sub {
          ...
          $quit->broadcast;
       });

       $quit->wait;

SEE ALSO
    Event modules: Coro::Event, Coro, Event, Glib::Event, Glib.

    Implementations: AnyEvent::Impl::Coro, AnyEvent::Impl::Event,
    AnyEvent::Impl::Glib, AnyEvent::Impl::Tk.

    Nontrivial usage example: Net::FCP.


