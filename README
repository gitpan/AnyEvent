NAME
    AnyEvent - provide framework for multiple event loops

    EV, Event, Coro::EV, Coro::Event, Glib, Tk, Perl - various supported
    event loops

SYNOPSIS
       use AnyEvent;

       my $w = AnyEvent->io (fh => $fh, poll => "r|w", cb => sub {
          ...
       });

       my $w = AnyEvent->timer (after => $seconds, cb => sub {
          ...
       });

       my $w = AnyEvent->condvar; # stores whether a condition was flagged
       $w->wait; # enters "main loop" till $condvar gets ->broadcast
       $w->broadcast; # wake up current and all future wait's

WHY YOU SHOULD USE THIS MODULE (OR NOT)
    Glib, POE, IO::Async, Event... CPAN offers event models by the dozen
    nowadays. So what is different about AnyEvent?

    Executive Summary: AnyEvent is *compatible*, AnyEvent is *free of
    policy* and AnyEvent is *small and efficient*.

    First and foremost, *AnyEvent is not an event model* itself, it only
    interfaces to whatever event model the main program happens to use in a
    pragmatic way. For event models and certain classes of immortals alike,
    the statement "there can only be one" is a bitter reality: In general,
    only one event loop can be active at the same time in a process.
    AnyEvent helps hiding the differences between those event loops.

    The goal of AnyEvent is to offer module authors the ability to do event
    programming (waiting for I/O or timer events) without subscribing to a
    religion, a way of living, and most importantly: without forcing your
    module users into the same thing by forcing them to use the same event
    model you use.

    For modules like POE or IO::Async (which is a total misnomer as it is
    actually doing all I/O *synchronously*...), using them in your module is
    like joining a cult: After you joined, you are dependent on them and you
    cannot use anything else, as it is simply incompatible to everything
    that isn't itself. What's worse, all the potential users of your module
    are *also* forced to use the same event loop you use.

    AnyEvent is different: AnyEvent + POE works fine. AnyEvent + Glib works
    fine. AnyEvent + Tk works fine etc. etc. but none of these work together
    with the rest: POE + IO::Async? no go. Tk + Event? no go. Again: if your
    module uses one of those, every user of your module has to use it, too.
    But if your module uses AnyEvent, it works transparently with all event
    models it supports (including stuff like POE and IO::Async, as long as
    those use one of the supported event loops. It is trivial to add new
    event loops to AnyEvent, too, so it is future-proof).

    In addition to being free of having to use *the one and only true event
    model*, AnyEvent also is free of bloat and policy: with POE or similar
    modules, you get an enourmous amount of code and strict rules you have
    to follow. AnyEvent, on the other hand, is lean and up to the point, by
    only offering the functionality that is necessary, in as thin as a
    wrapper as technically possible.

    Of course, if you want lots of policy (this can arguably be somewhat
    useful) and you want to force your users to use the one and only event
    model, you should *not* use this module.

DESCRIPTION
    AnyEvent provides an identical interface to multiple event loops. This
    allows module authors to utilise an event loop without forcing module
    users to use the same event loop (as only a single event loop can
    coexist peacefully at any one time).

    The interface itself is vaguely similar, but not identical to the Event
    module.

    During the first call of any watcher-creation method, the module tries
    to detect the currently loaded event loop by probing whether one of the
    following modules is already loaded: Coro::EV, Coro::Event, EV, Event,
    Glib, Tk. The first one found is used. If none are found, the module
    tries to load these modules in the stated order. The first one that can
    be successfully loaded will be used. If, after this, still none could be
    found, AnyEvent will fall back to a pure-perl event loop, which is not
    very efficient, but should work everywhere.

    Because AnyEvent first checks for modules that are already loaded,
    loading an event model explicitly before first using AnyEvent will
    likely make that model the default. For example:

       use Tk;
       use AnyEvent;

       # .. AnyEvent will likely default to Tk

    The *likely* means that, if any module loads another event model and
    starts using it, all bets are off. Maybe you should tell their authors
    to use AnyEvent so their modules work together with others seamlessly...

    The pure-perl implementation of AnyEvent is called
    "AnyEvent::Impl::Perl". Like other event modules you can load it
    explicitly.

WATCHERS
    AnyEvent has the central concept of a *watcher*, which is an object that
    stores relevant data for each kind of event you are waiting for, such as
    the callback to call, the filehandle to watch, etc.

    These watchers are normal Perl objects with normal Perl lifetime. After
    creating a watcher it will immediately "watch" for events and invoke the
    callback when the event occurs (of course, only when the event model is
    in control).

    To disable the watcher you have to destroy it (e.g. by setting the
    variable you store it in to "undef" or otherwise deleting all references
    to it).

    All watchers are created by calling a method on the "AnyEvent" class.

    Many watchers either are used with "recursion" (repeating timers for
    example), or need to refer to their watcher object in other ways.

    An any way to achieve that is this pattern:

      my $w; $w = AnyEvent->type (arg => value ..., cb => sub {
         # you can use $w here, for example to undef it
         undef $w;
      });

    Note that "my $w; $w =" combination. This is necessary because in Perl,
    my variables are only visible after the statement in which they are
    declared.

  IO WATCHERS
    You can create an I/O watcher by calling the "AnyEvent->io" method with
    the following mandatory key-value pairs as arguments:

    "fh" the Perl *file handle* (*not* file descriptor) to watch for events.
    "poll" must be a string that is either "r" or "w", which creates a
    watcher waiting for "r"eadable or "w"ritable events, respectively. "cb"
    is the callback to invoke each time the file handle becomes ready.

    File handles will be kept alive, so as long as the watcher exists, the
    file handle exists, too.

    It is not allowed to close a file handle as long as any watcher is
    active on the underlying file descriptor.

    Some event loops issue spurious readyness notifications, so you should
    always use non-blocking calls when reading/writing from/to your file
    handles.

    Example:

       # wait for readability of STDIN, then read a line and disable the watcher
       my $w; $w = AnyEvent->io (fh => \*STDIN, poll => 'r', cb => sub {
          chomp (my $input = <STDIN>);
          warn "read: $input\n";
          undef $w;
       });

  TIME WATCHERS
    You can create a time watcher by calling the "AnyEvent->timer" method
    with the following mandatory arguments:

    "after" specifies after how many seconds (fractional values are
    supported) should the timer activate. "cb" the callback to invoke in
    that case.

    The timer callback will be invoked at most once: if you want a repeating
    timer you have to create a new watcher (this is a limitation by both Tk
    and Glib).

    Example:

       # fire an event after 7.7 seconds
       my $w = AnyEvent->timer (after => 7.7, cb => sub {
          warn "timeout\n";
       });

       # to cancel the timer:
       undef $w;

    Example 2:

       # fire an event after 0.5 seconds, then roughly every second
       my $w;

       my $cb = sub {
          # cancel the old timer while creating a new one
          $w = AnyEvent->timer (after => 1, cb => $cb);
       };

       # start the "loop" by creating the first watcher
       $w = AnyEvent->timer (after => 0.5, cb => $cb);

   TIMING ISSUES
    There are two ways to handle timers: based on real time (relative, "fire
    in 10 seconds") and based on wallclock time (absolute, "fire at 12
    o'clock").

    While most event loops expect timers to specified in a relative way,
    they use absolute time internally. This makes a difference when your
    clock "jumps", for example, when ntp decides to set your clock backwards
    from the wrong 2014-01-01 to 2008-01-01, a watcher that you created to
    fire "after" a second might actually take six years to finally fire.

    AnyEvent cannot compensate for this. The only event loop that is
    conscious about these issues is EV, which offers both relative
    (ev_timer) and absolute (ev_periodic) timers.

    AnyEvent always prefers relative timers, if available, matching the
    AnyEvent API.

  SIGNAL WATCHERS
    You can watch for signals using a signal watcher, "signal" is the signal
    *name* without any "SIG" prefix, "cb" is the Perl callback to be invoked
    whenever a signal occurs.

    Multiple signals occurances can be clumped together into one callback
    invocation, and callback invocation will be synchronous. synchronous
    means that it might take a while until the signal gets handled by the
    process, but it is guarenteed not to interrupt any other callbacks.

    The main advantage of using these watchers is that you can share a
    signal between multiple watchers.

    This watcher might use %SIG, so programs overwriting those signals
    directly will likely not work correctly.

    Example: exit on SIGINT

       my $w = AnyEvent->signal (signal => "INT", cb => sub { exit 1 });

  CHILD PROCESS WATCHERS
    You can also watch on a child process exit and catch its exit status.

    The child process is specified by the "pid" argument (if set to 0, it
    watches for any child process exit). The watcher will trigger as often
    as status change for the child are received. This works by installing a
    signal handler for "SIGCHLD". The callback will be called with the pid
    and exit status (as returned by waitpid).

    Example: wait for pid 1333

      my $w = AnyEvent->child (
         pid => 1333,
         cb  => sub {
            my ($pid, $status) = @_;
            warn "pid $pid exited with status $status";
         },
      );

  CONDITION VARIABLES
    Condition variables can be created by calling the "AnyEvent->condvar"
    method without any arguments.

    A condition variable waits for a condition - precisely that the
    "->broadcast" method has been called.

    They are very useful to signal that a condition has been fulfilled, for
    example, if you write a module that does asynchronous http requests,
    then a condition variable would be the ideal candidate to signal the
    availability of results.

    You can also use condition variables to block your main program until an
    event occurs - for example, you could "->wait" in your main program
    until the user clicks the Quit button in your app, which would
    "->broadcast" the "quit" event.

    Note that condition variables recurse into the event loop - if you have
    two pirces of code that call "->wait" in a round-robbin fashion, you
    lose. Therefore, condition variables are good to export to your caller,
    but you should avoid making a blocking wait yourself, at least in
    callbacks, as this asks for trouble.

    This object has two methods:

    $cv->wait
        Wait (blocking if necessary) until the "->broadcast" method has been
        called on c<$cv>, while servicing other watchers normally.

        You can only wait once on a condition - additional calls will return
        immediately.

        Not all event models support a blocking wait - some die in that case
        (programs might want to do that to stay interactive), so *if you are
        using this from a module, never require a blocking wait*, but let
        the caller decide whether the call will block or not (for example,
        by coupling condition variables with some kind of request results
        and supporting callbacks so the caller knows that getting the result
        will not block, while still suppporting blocking waits if the caller
        so desires).

        Another reason *never* to "->wait" in a module is that you cannot
        sensibly have two "->wait"'s in parallel, as that would require
        multiple interpreters or coroutines/threads, none of which
        "AnyEvent" can supply (the coroutine-aware backends
        AnyEvent::Impl::CoroEV and AnyEvent::Impl::CoroEvent explicitly
        support concurrent "->wait"'s from different coroutines, however).

    $cv->broadcast
        Flag the condition as ready - a running "->wait" and all further
        calls to "wait" will (eventually) return after this method has been
        called. If nobody is waiting the broadcast will be remembered..

    Example:

       # wait till the result is ready
       my $result_ready = AnyEvent->condvar;

       # do something such as adding a timer
       # or socket watcher the calls $result_ready->broadcast
       # when the "result" is ready.
       # in this case, we simply use a timer:
       my $w = AnyEvent->timer (
          after => 1,
          cb    => sub { $result_ready->broadcast },
       );

       # this "blocks" (while handling events) till the watcher
       # calls broadcast
       $result_ready->wait;

GLOBAL VARIABLES AND FUNCTIONS
    $AnyEvent::MODEL
        Contains "undef" until the first watcher is being created. Then it
        contains the event model that is being used, which is the name of
        the Perl class implementing the model. This class is usually one of
        the "AnyEvent::Impl:xxx" modules, but can be any other class in the
        case AnyEvent has been extended at runtime (e.g. in *rxvt-unicode*).

        The known classes so far are:

           AnyEvent::Impl::CoroEV    based on Coro::EV, best choice.
           AnyEvent::Impl::CoroEvent based on Coro::Event, second best choice.
           AnyEvent::Impl::EV        based on EV (an interface to libev, also best choice).
           AnyEvent::Impl::Event     based on Event, also second best choice :)
           AnyEvent::Impl::Glib      based on Glib, third-best choice.
           AnyEvent::Impl::Tk        based on Tk, very bad choice.
           AnyEvent::Impl::Perl      pure-perl implementation, inefficient but portable.

    AnyEvent::detect
        Returns $AnyEvent::MODEL, forcing autodetection of the event model
        if necessary. You should only call this function right before you
        would have created an AnyEvent watcher anyway, that is, as late as
        possible at runtime.

WHAT TO DO IN A MODULE
    As a module author, you should "use AnyEvent" and call AnyEvent methods
    freely, but you should not load a specific event module or rely on it.

    Be careful when you create watchers in the module body - AnyEvent will
    decide which event module to use as soon as the first method is called,
    so by calling AnyEvent in your module body you force the user of your
    module to load the event module first.

    Never call "->wait" on a condition variable unless you *know* that the
    "->broadcast" method has been called on it already. This is because it
    will stall the whole program, and the whole point of using events is to
    stay interactive.

    It is fine, however, to call "->wait" when the user of your module
    requests it (i.e. if you create a http request object ad have a method
    called "results" that returns the results, it should call "->wait"
    freely, as the user of your module knows what she is doing. always).

WHAT TO DO IN THE MAIN PROGRAM
    There will always be a single main program - the only place that should
    dictate which event model to use.

    If it doesn't care, it can just "use AnyEvent" and use it itself, or not
    do anything special (it does not need to be event-based) and let
    AnyEvent decide which implementation to chose if some module relies on
    it.

    If the main program relies on a specific event model. For example, in
    Gtk2 programs you have to rely on the Glib module. You should load the
    event module before loading AnyEvent or any module that uses it:
    generally speaking, you should load it as early as possible. The reason
    is that modules might create watchers when they are loaded, and AnyEvent
    will decide on the event model to use as soon as it creates watchers,
    and it might chose the wrong one unless you load the correct one
    yourself.

    You can chose to use a rather inefficient pure-perl implementation by
    loading the "AnyEvent::Impl::Perl" module, which gives you similar
    behaviour everywhere, but letting AnyEvent chose is generally better.

SUPPLYING YOUR OWN EVENT MODEL INTERFACE
    This is an advanced topic that you do not normally need to use AnyEvent
    in a module. This section is only of use to event loop authors who want
    to provide AnyEvent compatibility.

    If you need to support another event library which isn't directly
    supported by AnyEvent, you can supply your own interface to it by
    pushing, before the first watcher gets created, the package name of the
    event module and the package name of the interface to use onto
    @AnyEvent::REGISTRY. You can do that before and even without loading
    AnyEvent, so it is reasonably cheap.

    Example:

       push @AnyEvent::REGISTRY, [urxvt => urxvt::anyevent::];

    This tells AnyEvent to (literally) use the "urxvt::anyevent::"
    package/class when it finds the "urxvt" package/module is already
    loaded.

    When AnyEvent is loaded and asked to find a suitable event model, it
    will first check for the presence of urxvt by trying to "use" the
    "urxvt::anyevent" module.

    The class should provide implementations for all watcher types. See
    AnyEvent::Impl::EV (source code), AnyEvent::Impl::Glib (Source code) and
    so on for actual examples. Use "perldoc -m AnyEvent::Impl::Glib" to see
    the sources.

    If you don't provide "signal" and "child" watchers than AnyEvent will
    provide suitable (hopefully) replacements.

    The above example isn't fictitious, the *rxvt-unicode* (a.k.a. urxvt)
    terminal emulator uses the above line as-is. An interface isn't included
    in AnyEvent because it doesn't make sense outside the embedded
    interpreter inside *rxvt-unicode*, and it is updated and maintained as
    part of the *rxvt-unicode* distribution.

    *rxvt-unicode* also cheats a bit by not providing blocking access to
    condition variables: code blocking while waiting for a condition will
    "die". This still works with most modules/usages, and blocking calls
    must not be done in an interactive application, so it makes sense.

ENVIRONMENT VARIABLES
    The following environment variables are used by this module:

    "PERL_ANYEVENT_VERBOSE" when set to 2 or higher, cause AnyEvent to
    report to STDERR which event model it chooses.

EXAMPLE PROGRAM
    The following program uses an IO watcher to read data from STDIN, a
    timer to display a message once per second, and a condition variable to
    quit the program when the user enters quit:

       use AnyEvent;

       my $cv = AnyEvent->condvar;

       my $io_watcher = AnyEvent->io (
          fh   => \*STDIN,
          poll => 'r',
          cb   => sub {
             warn "io event <$_[0]>\n";   # will always output <r>
             chomp (my $input = <STDIN>); # read a line
             warn "read: $input\n";       # output what has been read
             $cv->broadcast if $input =~ /^q/i; # quit program if /^q/i
          },
       );

       my $time_watcher; # can only be used once

       sub new_timer {
          $timer = AnyEvent->timer (after => 1, cb => sub {
             warn "timeout\n"; # print 'timeout' about every second
             &new_timer; # and restart the time
          });
       }

       new_timer; # create first timer

       $cv->wait; # wait until user enters /^q/i

REAL-WORLD EXAMPLE
    Consider the Net::FCP module. It features (among others) the following
    API calls, which are to freenet what HTTP GET requests are to http:

       my $data = $fcp->client_get ($url); # blocks

       my $transaction = $fcp->txn_client_get ($url); # does not block
       $transaction->cb ( sub { ... } ); # set optional result callback
       my $data = $transaction->result; # possibly blocks

    The "client_get" method works like "LWP::Simple::get": it requests the
    given URL and waits till the data has arrived. It is defined to be:

       sub client_get { $_[0]->txn_client_get ($_[1])->result }

    And in fact is automatically generated. This is the blocking API of
    Net::FCP, and it works as simple as in any other, similar, module.

    More complicated is "txn_client_get": It only creates a transaction
    (completion, result, ...) object and initiates the transaction.

       my $txn = bless { }, Net::FCP::Txn::;

    It also creates a condition variable that is used to signal the
    completion of the request:

       $txn->{finished} = AnyAvent->condvar;

    It then creates a socket in non-blocking mode.

       socket $txn->{fh}, ...;
       fcntl $txn->{fh}, F_SETFL, O_NONBLOCK;
       connect $txn->{fh}, ...
          and !$!{EWOULDBLOCK}
          and !$!{EINPROGRESS}
          and Carp::croak "unable to connect: $!\n";

    Then it creates a write-watcher which gets called whenever an error
    occurs or the connection succeeds:

       $txn->{w} = AnyEvent->io (fh => $txn->{fh}, poll => 'w', cb => sub { $txn->fh_ready_w });

    And returns this transaction object. The "fh_ready_w" callback gets
    called as soon as the event loop detects that the socket is ready for
    writing.

    The "fh_ready_w" method makes the socket blocking again, writes the
    request data and replaces the watcher by a read watcher (waiting for
    reply data). The actual code is more complicated, but that doesn't
    matter for this example:

       fcntl $txn->{fh}, F_SETFL, 0;
       syswrite $txn->{fh}, $txn->{request}
          or die "connection or write error";
       $txn->{w} = AnyEvent->io (fh => $txn->{fh}, poll => 'r', cb => sub { $txn->fh_ready_r });

    Again, "fh_ready_r" waits till all data has arrived, and then stores the
    result and signals any possible waiters that the request ahs finished:

       sysread $txn->{fh}, $txn->{buf}, length $txn->{$buf};

       if (end-of-file or data complete) {
         $txn->{result} = $txn->{buf};
         $txn->{finished}->broadcast;
         $txb->{cb}->($txn) of $txn->{cb}; # also call callback
       }

    The "result" method, finally, just waits for the finished signal (if the
    request was already finished, it doesn't wait, of course, and returns
    the data:

       $txn->{finished}->wait;
       return $txn->{result};

    The actual code goes further and collects all errors ("die"s,
    exceptions) that occured during request processing. The "result" method
    detects whether an exception as thrown (it is stored inside the $txn
    object) and just throws the exception, which means connection errors and
    other problems get reported tot he code that tries to use the result,
    not in a random callback.

    All of this enables the following usage styles:

    1. Blocking:

       my $data = $fcp->client_get ($url);

    2. Blocking, but running in parallel:

       my @datas = map $_->result,
                      map $fcp->txn_client_get ($_),
                         @urls;

    Both blocking examples work without the module user having to know
    anything about events.

    3a. Event-based in a main program, using any supported event module:

       use EV;

       $fcp->txn_client_get ($url)->cb (sub {
          my $txn = shift;
          my $data = $txn->result;
          ...
       });

       EV::loop;

    3b. The module user could use AnyEvent, too:

       use AnyEvent;

       my $quit = AnyEvent->condvar;

       $fcp->txn_client_get ($url)->cb (sub {
          ...
          $quit->broadcast;
       });

       $quit->wait;

SEE ALSO
    Event modules: Coro::EV, EV, EV::Glib, Glib::EV, Coro::Event, Event,
    Glib::Event, Glib, Coro, Tk.

    Implementations: AnyEvent::Impl::CoroEV, AnyEvent::Impl::EV,
    AnyEvent::Impl::CoroEvent, AnyEvent::Impl::Event, AnyEvent::Impl::Glib,
    AnyEvent::Impl::Tk, AnyEvent::Impl::Perl.

    Nontrivial usage examples: Net::FCP, Net::XMPP2.


